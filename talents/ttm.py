"""Updates profile names from TTM to be more readable"""
import math
import os
import yaml

with open("../config.yml", "r", encoding="utf8") as ymlfile:
    config = yaml.load(ymlfile, Loader=yaml.FullLoader)


def apply_rules(line):
    # Don't add combos that waste points on TS without Yogg
    if "tormented_spirits" in line and "idol_of_yoggsaron" not in line:
        return True

    # # Make sure you are efficiently spending points
    HALF_SELECTED_MID_TALENTS = 0
    for t in [
        "maddening_touch",
        "instilled_doubt",
        "phantasmal_pathogen",
        "mastermind",
    ]:  # noqa: E501
        if t + ":1" in line:
            HALF_SELECTED_MID_TALENTS = HALF_SELECTED_MID_TALENTS + 1
    if HALF_SELECTED_MID_TALENTS >= 2:
        return True

    HALF_SELECTED_BOT_TALENTS = 0
    for t in ["madness_weaving", "screams_of_the_void", "insidious_ire"]:
        if t + ":1" in line:
            HALF_SELECTED_BOT_TALENTS = HALF_SELECTED_BOT_TALENTS + 1
    if HALF_SELECTED_BOT_TALENTS >= 2:
        return True

    # make sure you have 9+ talent points in the bottom section
    BOTTOM_TALENTS = 0
    for t in [
        "mindbender",
        "deathspeaker",
        "mind_devourer",
        "auspicious_spirits",
        "void_torrent",
        "inescapable_torment",
        "madness_weaving",
        "deaths_torment",
        "insidious_ire",
        "screams_of_the_void",
        "tormented_spirits",
        "insidious_ire",
        "void_volley",
        "idol_of_yshaarj",
        "idol_of_nzoth",
        "idol_of_yoggsaron",
        "idol_of_cthun",
    ]:
        if t + ":1" in line:
            BOTTOM_TALENTS = BOTTOM_TALENTS + 1
        if t + ":2" in line:
            BOTTOM_TALENTS = BOTTOM_TALENTS + 2
    if BOTTOM_TALENTS < 9:
        return True

    # default case
    return False


def convert_builds(profile):
    OUTPUT_FILE = ""
    lines_seen = set()
    with open(profile, "r", encoding="utf8") as file:
        data = file.readlines()
        file.close()

    SIGNATURE = "# Automatically generated by ttm.py\n"
    if data[0] != SIGNATURE:
        data = [SIGNATURE] + data
    else:
        print(f"{profile} has already been generated, skipping file.")
        return

    for line in data:
        # Since we only have one Shadow Crash, force to the target version
        line = line.replace("shadow_crash:1", "133524:1")
        if "Solved loadout " not in line:
            if line not in lines_seen or line.isspace():
                if "profileset" in line and apply_rules(line):
                    continue
                lines_seen.add(line)
                OUTPUT_FILE = OUTPUT_FILE + line
            continue
        prefix = ""
        if "dark_ascension" in line:
            prefix = "DA"
        elif "void_eruption" in line:
            prefix = "VF"
        TALENT = prefix
        line = line.replace("Solved loadout ", TALENT + "_")
        # detect flay or spike and dr or me
        has_shadow_crash = "133524" in line
        has_distorted_reality = "distorted_reality" in line
        has_minds_eye = "minds_eye" in line
        has_mental_decay = "mental_decay" in line
        has_shattered_psyche = "shattered_psyche" in line
        suffix = ""
        # ME or DR
        if has_distorted_reality:
            suffix += "DR"
        elif has_minds_eye:
            suffix += "ME"
        # Shadow Crash
        if has_shadow_crash:
            suffix += "_SC"
        # MeD or ShP
        if has_mental_decay:
            suffix += "_MeD"
        elif has_shattered_psyche:
            suffix += "_ShP"
        # TODO: figure out a better way to do this
        line = line.replace(" 21111", "_" + suffix)
        line = line.replace(" 21121", "_" + suffix)

        if apply_rules(line):
            continue

        idols = ["yshaarj", "nzoth", "yogg", "cthun"]
        IDOLS_USED = ""
        IDOLS_COUNT = 0
        for idol in idols:
            if idol in line:
                IDOLS_COUNT = IDOLS_COUNT + 1
                if len(IDOLS_USED) > 1:
                    IDOLS_USED += "_"
                IDOLS_USED += idol
        if len(IDOLS_USED) > 1:
            IDOLS_USED = "_" + IDOLS_USED
        line = line.replace(
            f'profileset."{TALENT}', f'profileset."{TALENT}{IDOLS_USED}'
        )

        # ONLY ALLOW 1+ IDOL BUILDS
        if IDOLS_COUNT > 0 and line not in lines_seen:
            lines_seen.add(line)
            OUTPUT_FILE = OUTPUT_FILE + line

    with open(profile, "w", encoding="utf8") as file:
        file.writelines(OUTPUT_FILE)
        file.close()


class Talents:
    def __init__(self, st, ct, ht):
        self.st = st
        self.ct = ct
        self.ht = ht


def duplicate_builds():
    hero_talents = ["AR", "VW"]
    # TODO: skip duplicate if a comment is added? this can take a long time
    for hero_talent in hero_talents:
        with open(f"hero_{hero_talent}.simc", "r", encoding="utf8") as file:
            data = file.readlines()
            file.close()
        print(f"Starting with {len(data)} builds")
        # duplicate all builds for minds_eye
        me_data = list(map(lambda x: x.replace("distorted_reality", "minds_eye"), data))
        me_data = list(map(lambda x: x.replace("_DR", "_ME"), me_data))
        data = me_data + data
        print(f"{len(data)} builds after duplicating for Mind's Eye")
        # duplicate all builds for void_eruption
        vf_data = list(
            map(lambda x: x.replace("dark_ascension", "void_eruption"), data)
        )
        vf_data = list(map(lambda x: x.replace("DA_", "VF_"), vf_data))
        data = vf_data + data
        print(f"{len(data)} builds after duplicating for Void Eruption")
        # create talent dictionary
        talents = {}
        for line in data:
            if "# Automatically generated by ttm.py" in line:
                continue
            name = line.split("+=")[0].split("profileset.")[1].replace('"', "")
            value = line.split("+=", 1)[1].replace('"', "").strip()
            talents[name] = value
        # duplicate all builds for each hero talent combo
        hero_talents = {}
        for build in config["hero"][hero_talent]:
            print(f"Duplicating builds for {build}...")
            talent_string = config["hero"][hero_talent][build]
            for talent in talents:
                name = f"{build}_{talent}"
                hero_line = f'profileset."{name}"+="hero_talents={talent_string}"\n'
                class_line = ""
                if hero_talent == "AR":
                    class_line = (
                        f'profileset."{name}"+="class_talents+=/halo:1/divine_star:0"\n'
                    )
                spec_line = f'profileset."{name}"+="{talents[talent]}"\n'
                hero_talents[name] = Talents(spec_line, class_line, hero_line)
        print(f"Writing builds to hero_{hero_talent}_duplicated.simc")
        with open(f"hero_{hero_talent}_duplicated.simc", "w", encoding="utf8") as file:
            for build in hero_talents:
                file.writelines(hero_talents[build].st)
                file.writelines(hero_talents[build].ht)
                if hero_talents[build] != "":
                    file.writelines(hero_talents[build].ct)
            file.close()


def make_build_files():
    hero_talents = ["AR", "VW"]
    data = list()
    for hero_talent in hero_talents:
        with open(f"hero_{hero_talent}_duplicated.simc", "r", encoding="utf8") as file:
            data = data + file.readlines()
            file.close()
    with open("base.simc", "r", encoding="utf8") as file:
        base = file.readlines()
        file.close()
    # clear out old files
    for filename in os.listdir("builds/"):
        if os.path.isfile(os.path.join("builds/", filename)):
            os.remove(os.path.join("builds/", filename))
    # TODO make this number configurable
    batch_size = 4002
    batches = math.ceil(len(data) / batch_size)
    # TODO: these batches can cause problems now that builds are no longer on one line (2 for VW, 3 for AR)
    # refactor so this doesnt break
    for batch in range(batches):
        start = 0 + (batch_size * batch)
        end = batch_size + (batch_size * batch)
        with open(f"builds/talents_{batch}.simc", "w", encoding="utf8") as file:
            file.writelines(base)
            for line in data[start:end]:
                file.write(line)
        file.close()


if __name__ == "__main__":
    convert_builds("hero_AR.simc")
    convert_builds("hero_VW.simc")
    duplicate_builds()
    make_build_files()
